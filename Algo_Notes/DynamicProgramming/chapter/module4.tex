\chapter{Kỹ thuật đổi biến số trong Quy hoạch động}

\minitoc

\section{Lý thuyết}

Với kỹ thuật đổi biến số, chúng ta đừng nhìn nhận/gọi $f[\cdot]$ là đáp án của bài toán nữa, mà hãy xem $f[\cdot]$ như là một cái chiều của QHĐ.

\section{Vấn đề}

\subsection{Bài toán Knapsack}

\begin{baitap}{Knapsack 2}{https://atcoder.jp/contests/dp/tasks/dp\_e}

Có $N$ đồ vật, được đánh số từ $1,2,\ldots,N$. Với mỗi đồ vật $i \ (1 \leq i \leq N)$, đồ vật $i$ có trọng lượng $w_i$ và giá trị $v_i$.  

Taro muốn chọn một số đồ vật trong $N$ đồ vật này và mang về bằng một chiếc ba lô. Chiếc ba lô có sức chứa $W$, nghĩa là tổng trọng lượng các đồ vật được chọn không được vượt quá $W$.  

\textbf{Yêu cầu}  

Hãy tìm tổng giá trị lớn nhất của các đồ vật mà Taro có thể mang về.  

\textbf{Giới hạn}  
\begin{itemize}[noitemsep]
  \item $1 \leq N \leq 100$
  \item $1 \leq W \leq 10^9$
  \item $1 \leq w_i \leq W$
  \item $1 \leq v_i \leq 10^3$
\end{itemize}

\textbf{Input}  
\begin{itemize}[noitemsep]
  \item Dòng đầu tiên chứa hai số nguyên $N, W$ — số lượng đồ vật và sức chứa của ba lô.
  \item Trong $N$ dòng tiếp theo, dòng thứ $i$ chứa hai số $w_i, v_i$ — trọng lượng và giá trị của đồ vật $i$.
\end{itemize}

\textbf{Output}  
In ra một số nguyên duy nhất — tổng giá trị lớn nhất có thể.  

\textbf{Ví dụ}  

\begin{sampleio}
3 8 & 90 \\
3 30 & \\
4 50 & \\
5 60 & \\
\end{sampleio}

\textbf{Giải thích}  

Trong ví dụ, chọn đồ vật 1 và 3. Khi đó tổng trọng lượng $3+5=8$, và tổng giá trị $30+60=90$.  

\end{baitap}

\subsection{Nhận xét}

Bài toán khác với Knapsack cổ điển ở chỗ giới hạn tải trọng rất lớn ($W \le 10^9$), nên không thể quy hoạch động theo \emph{trọng lượng} như thường lệ (vì chiều theo $W$ sẽ quá lớn).

Ta có thể tư duy rằng \textbf{đảo chiều} quy hoạch động theo \emph{giá trị}: đặt
\[
f[i][j] = \text{khối lượng nhỏ nhất có thể đạt được khi xét } i \text{ đồ vật đầu tiên và tổng giá trị đúng bằng } j,
\]
và quy ước $f[i][j]=+\infty$ nếu không thể đạt tổng giá trị $j$.

\textbf{Trường hợp cơ sở:}
\[
f[0][0] = 0,\qquad f[0][j] = +\infty, \ \forall j>0.
\]

\textbf{Chuyển trạng thái:} với đồ vật $i$ có trọng lượng $w_i$ và giá trị $v_i$,
\[
f[i][j] =
\begin{cases}
\min\big(f[i-1][j],\ f[i-1][j - v_i] + w_i\big), & \text{nếu } j \ge v_i,\\[4pt]
f[i-1][j], & \text{nếu } j < v_i.
\end{cases}
\]

\textbf{Kết quả bài toán:} $\max \{\, j \mid f[n][j] \le W \,\}.$\\


Vì $j$ chỉ cần chạy đến $V_{\max}=\sum_{i=1}^N v_i \le 10^5$, độ phức tạp là $O(N\,V_{\max})$, phù hợp  với giới hạn bài toán. 

\begin{lstlisting}[title=\centering \textbf{Cài đặt}]
#include <bits/stdc++.h>
#define int long long
const int oo = 1e18 + 7;
using namespace std;

struct item {
    int w, v;
};

signed main() {
    int n, w; cin >> n >> w;
    vector<item> a(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i].w >> a[i].v;
    }    
    int MAXV = 1e5;
    vector<vector<int>> dp(n + 1, vector<int>(MAXV + 5, oo));

    dp[0][0] = 0;

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= MAXV; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j - a[i].v < 0) continue;
            dp[i][j] = min(dp[i][j], dp[i - 1][j - a[i].v] + a[i].w);
        }
    }

    int ans = 0;
    for (int j = 0; j <= MAXV; j++) {
        if (dp[n][j] <= w)
            ans = j;
    }
    cout << ans;
}
\end{lstlisting}


\subsection{Bài toán Dãy con tăng dài nhất}

\begin{baitap}{Dãy con tăng dài nhất}{https://oj.vnoi.info/problem/lis}

Cho một dãy gồm $N$ số nguyên $(1 \leq N \leq 30000)$. Hãy tìm dãy con tăng dài nhất trong dãy đó. In ra số lượng phần tử của dãy con. Các số trong phạm vi longint.

\textbf{Input}  
\begin{itemize}[noitemsep]
  \item Dòng đầu tiên chứa số nguyên $N$.
  \item Dòng thứ hai gồm $N$ số mô tả dãy.
\end{itemize}

\textbf{Output}  
In ra một số nguyên duy nhất là đáp số bài toán.

\textbf{Ví dụ}  

\begin{sampleio}
5 & 3 \\
2 1 4 3 5 & \\
\end{sampleio}

\end{baitap}

\subsection{Nhận xét}

Với bài toán LIS cơ bản, ta có thể đặt 
$f[i] = \text{độ dài dãy con tăng dài nhất kết thúc tại vị trí } i,$
và duyệt hai vòng \texttt{for} để tính toán. Tuy nhiên, với ràng buộc $N \leq 30000,$thì cách làm này có độ phức tạp $O(N^2) \approx 30000^2 = 9 \times 10^8$ phép toán, chắc chắn sẽ bị \texttt{TLE}. \\

Do đó, ta chuyển sang cách định nghĩa khác. Gọi $f[\texttt{len}]$ là \textbf{chỉ số} của phần tử kết thúc có giá trị nhỏ nhất trong tất cả những dãy con tăng có độ dài bằng \texttt{len} tính đến \textbf{thời điểm hiện tại}.\\

Xét \texttt{a[20] = \{0, 9, 1, 5, 6, 3, 8, 8, 4, 3, 9, 10, 15, 2, 7, 1, 5, 6, 3, 8\}} (a[0] được thêm vào chỉ để thuận tiện cho việc định nghĩa bài toán cơ sở sau này).

Giả sử ta xét $i = 7:$
\begin{itemize}
  \item Với \texttt{len = 2}, ta có những dãy con tăng như sau: [1, 5], [1, 6], [1, 3], [1, 8], [5, 6], [5, 8], [6, 8].
  \item Vậy $f[2] = 5$ (dãy [a[2], a[5]])
\end{itemize}

Giả sử ta xét $i = 10:$
\begin{itemize}
  \item f[3] = 8
\end{itemize}

\textbf{Bài toán cơ sở:} f[0] = 0,  $f[i] = -1, \  1 \leq i \leq n$

\textbf{Kết quả bài toán:} Ta tìm \texttt{len} lớn nhất sao cho $f[\texttt{len}] \neq -1$ 

\textbf{Phân tích bài toán:}

Vì mảng $f$ là một dãy không giảm $(f_i \leq f_{i + 1}, \ \forall i)$, để tìm độ dài dãy con tăng dài nhất kết thúc tại vị trí $i$, ta phải tìm $j$ lớn nhất thỏa mãn: $a_{f_j} < a_i$. Như vậy, ta có thể tạo ra một dãy con tăng có độ dài $j + 1$. 

\textbf{Chứng minh $f$ là dãy không giảm}

Xét định nghĩa: $f[\texttt{len}]$ là chỉ số của phần tử có giá trị nhỏ nhất trong tất cả các dãy con tăng có độ dài đúng bằng \texttt{len}, tính đến thời điểm hiện tại.

Ta cần chứng minh:
\[
f[1] \leq f[2] \leq \dots \leq f[\texttt{len}_{\max}]
\]

\textbf{Lý do:}

\begin{itemize}
  \item Một dãy con tăng có độ dài $k+1$ được tạo ra bằng cách nối thêm một phần tử vào đuôi của một dãy con tăng độ dài $k$.
  \item Do đó, nếu $f[k]$ là chỉ số phần tử kết thúc của dãy con tăng độ dài $k$, thì $f[k+1]$ phải là chỉ số phần tử nằm \emph{bên phải} $f[k]$ trong mảng gốc.
  \item Mặt khác, ta luôn chọn phần tử kết thúc có \emph{giá trị nhỏ nhất} cho mỗi độ dài. Điều này đảm bảo rằng chỉ số kết thúc của dãy độ dài $k+1$ không thể “quay ngược” về trước, tức là không thể nhỏ hơn $f[k]$.
\end{itemize}

Vậy ta có quan hệ:
\[
f[k] \leq f[k+1], \quad \forall k.
\]

Hay nói cách khác, dãy các chỉ số $f$ là \textbf{không giảm}.\\

Do mảng $f$ là một dãy không giảm, ta dễ dàng tìm kiếm được vị trí $j$ lớn nhất bằng \texttt{tìm kiếm nhị phân}.

\begin{lstlisting}[title=\centering \textbf{Cài đặt}]
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n; cin >> n;
    vector<int> a(n + 1), f(n + 1, -1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    f[0] = 0;
    a[0] = 0;
    int len = 0;
    for (int i = 1; i <= n; i++) {
        int l = 0, r = len, pos = 0;
        while (l <= r) {
            int mid = l + r >> 1;
            if (a[i] > a[f[mid]]) {
                pos = mid;
                l = mid + 1;
            }
            else {
                r = mid - 1;
            }
        }
        f[pos + 1] = i;
        if (pos + 1 > len) len++;
    }
    cout << len;
}
\end{lstlisting}

\section{Bài tập}

\begin{baitap}{SC1}{SUMMER CONTEST 2021}

Kỳ nghỉ Tết cũng đã kết thúc, Quang đã kiếm chác được một số tiền khá lớn dựa vào tiền lì xì,
tiền đánh bài, lô tô, tổ tôm, bầu cua, cá ngựa. Số tiền của Quang tích góp sau Tết sau khi thống
kê lại, được $a_1$ tờ 1.000 đồng, $a_2$ tờ 2.000 đồng, $a_3$ tờ 5.000 đồng, $a_4$ tờ 10.000 đồng, 
$a_5$ tờ 20.000 đồng, $a_6$ tờ 50.000 đồng, $a_7$ tờ 100.000 đồng, $a_8$ tờ 200.000 đồng, 
$a_9$ tờ 500.000 đồng. \\

Quang quyết định bỏ tiền của mình vào ống heo để tiết kiệm. Tuy nhiên, Quang sẽ muốn ăn
mừng 1 bữa thắng lớn. Thế là Quang chạy ra tiệm trà sữa Giun Giun, Quang gọi 1 ly trà sữa Thái
trân châu đường đen full topping, ca cao, phô mai, kem cheese, bánh flan, bánh quế, 100\%
đường 20\% đá size XXL. Quả nhiên là 1 ly trà sữa hảo hạng.\\

Số tiền để mua ly trà sữa này là $C$ (đồng) và $C$ chia hết cho 1000. Tiệm trà sữa Giun Giun hiện tại
đang có $b_1$ tờ 1.000 đồng, $b_2$ tờ 2.000 đồng, $b_3$ tờ 5.000 đồng, $b_4$ tờ 10.000 đồng, 
$b_5$ tờ 20.000 đồng, $b_6$ tờ 50.000 đồng, $b_7$ tờ 100.000 đồng, $b_8$ tờ 200.000 đồng, 
$b_9$ tờ 500.000 đồng trong quầy tính tiền. \\

Vì chú heo đất của Quang không to lắm, nên Quang muốn tống khứ càng nhiều tờ
tiền của mình càng tốt. Quang có thể trả tiền cho ly trà sữa với một số tiền là $X$ ($X > C$) 
và quán Giun Giun phải thối lại cho Quang $X - C$ đồng. Vì là 1 tiệm kinh doanh trà sữa, 
nên bà chủ Giun Giun muốn tống khứ càng ít tiền của quán càng tốt. \\

Hãy giúp Quang tính xem số tiền tối thiểu mà Quang sẽ có nếu thực
hiện xong thương vụ mua trà sữa.

\textbf{Input}  
\begin{itemize}[noitemsep]
  \item Dòng đầu tiên chứa số nguyên dương $T$ ($1 \leq T \leq 40$) là số lượng bộ dữ liệu.
  \item Mỗi bộ dữ liệu gồm:
  \begin{itemize}
    \item Dòng đầu tiên chứa số nguyên dương $C$ là giá tiền của ly trà sữa ($C$ chia hết cho 1000).
    \item 9 dòng tiếp theo, dòng thứ $i$ có định dạng \texttt{c[i]: a[i] b[i]}, trong đó 
    
    $c[i] \in \{1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000\}$ là mệnh giá, 
    $a[i]$ là số tờ tiền Quang có, $b[i]$ là số tờ tiền quán có.
  \end{itemize}
\end{itemize}

\textbf{Output}  
\begin{itemize}[noitemsep]
  \item Với mỗi bộ dữ liệu, in ra số tờ tiền mà Quang sẽ có sau khi mua trà sữa.
  \item Nếu không thể mua, in ra chuỗi \texttt{SORRY!!!}.
\end{itemize}

\textbf{Ví dụ}  

\begin{sampleio}
\textbf{Input:} & \textbf{Output:} \\
5 & \\
52000 & 7 \\
1000: 0 1 & SORRY!!! \\
2000: 0 1 & 10 \\
5000: 5 0 & 7 \\
10000: 2 0 & 6 \\
20000: 1 5 & \\
50000: 1 0 & \\
100000: 5 12 & \\
200000: 0 15 & \\
500000: 2 20 & \\
50000 & \\
1000: 0 0 & \\
2000: 3 0 & \\
5000: 9 0 & \\
10000: 0 0 & \\
20000: 0 0 & \\
50000: 0 0 & \\
100000: 0 0 & \\
200000: 0 0 & \\
500000: 0 0 & \\
200000 & \\
1000: 0 0 & \\
2000: 0 0 & \\
5000: 0 0 & \\
10000: 0 0 & \\
20000: 0 0 & \\
50000: 0 0 & \\
100000: 2 0 & \\
200000: 5 0 & \\
500000: 5 0 & \\
600000 & \\
1000: 1 51 & \\
2000: 1 24 & \\
5000: 1 42 & \\
10000: 1 52 & \\
20000: 1 11 & \\
50000: 1 4 & \\
100000: 1 0 & \\
200000: 1 5 & \\
500000: 1 24 & \\
58000 & \\
1000: 3 2 & \\
2000: 1 5 & \\
5000: 0 5 & \\
10000: 2 12 & \\
20000: 5 12 & \\
50000: 9 24 & \\
100000: 1 15 & \\
200000: 4 5 & \\
500000: 9 12 & \\
\end{sampleio}

\textbf{Giải thích test ví dụ:}
\begin{itemize}
  \item Với ví dụ 1: Ly trà sữa có giá 52000 đồng, nhưng Quang sẽ đưa cho bà chủ quán tận 555000 đồng. Quang đưa 5 tờ 100.000, 1 tờ 20.000, 1 tờ 10.000 và 5 tờ 5.000. Chủ quán sẽ thối lại Quang 555000 - 52000 = 503000, gồm 1 tờ 500.000, 1 tờ 2.000 và 1 tờ 1.000. Tổng số tờ tiền mà Quang có sau khi mua trà sữa là 7
  \item Với ví dụ 2: Quang có 9 tờ 5.000 và 3 tờ 2.000, tổng tiền Quang có là 51.000 và quán phải thối lại quan 1.000. Tuy nhiên quán không còn 1 tờ tiền nào cả nên giao dịch này không thể thực hiện được.
  \item Với ví dụ 3: Ly trà sữa có giá 200000 và Quang trả 2 tờ 100.000. Quang còn lại 10 tờ.
  \item Những ví dụ còn lại, chỉ dành để cho các bạn kiểm tra xem thuật toán của mình đã đúng hay chưa mà thôi.
\end{itemize}

\textbf{Giới hạn dữ liệu:}
\begin{itemize}
  \item Small Dataset: $0 \leq a[i], b[i] \leq 1$
  \item Large Dataset: $0 \leq a[i], b[i] \leq 70$
  \item $C \leq 70{,}000{,}000$
\end{itemize}

\end{baitap}


\textbf{Phân tích bài toán:}

\textbf{Bài toán cơ sở:}
\textbf{Kết quả bài toán:}



\begin{lstlisting}[title=\centering \textbf{Cài đặt}]

\end{lstlisting}

