\chapter{Tổ hợp (Combinatorics)}

\minitoc

\section{Lý thuyết}

Tổ hợp là một ngành nghiên cứu toán học chuyên nghiên cứu về các trạng thái, các cấu hình của một sự vật, sự việc hoặc phương pháp nào đó.

\subsection{Công cụ toán học cơ bản}
\label{subsec:comb-basic}

\begin{dinhnghia}[Giai thừa, chỉnh hợp, tổ hợp]
Với $n\in\mathbb{N}$, \textbf{giai thừa} $n! = 1\cdot 2\cdot \cdots \cdot n$ (quy ước $0!=1$).\\
\textbf{Chỉnh hợp} $P(n,k)=\dfrac{n!}{(n-k)!}$: số cách chọn \emph{có thứ tự} $k$ phần tử từ $n$ phần tử phân biệt.\\
\textbf{Tổ hợp} $C(n,k)=\binom{n}{k}=\dfrac{n!}{k!(n-k)!}$: số cách chọn \emph{không thứ tự} $k$ phần tử từ $n$ phần tử phân biệt ($0\le k\le n$).
\end{dinhnghia}

\begin{tinhchat}[Một số tính chất cơ bản]
\[
\binom{n}{0}=\binom{n}{n}=1,\qquad
\binom{n}{k}=\binom{n}{n-k},\qquad
\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}.
\]
\end{tinhchat}



\subsection{Kỹ thuật tính toán trong lập trình thi đấu}
\label{subsec:comb-impl}

\paragraph{Số học modulo (MOD nguyên tố)}
Trong đa số bài, MOD là số nguyên tố (ví dụ $10^9{+}7$ hoặc $998\,244\,353$). Với $p$ nguyên tố và $a\not\equiv 0\pmod p$:
\[
a^{-1}\bmod p \equiv a^{\,p-2}\ (\text{Fermat nhỏ}).
\]
Chuẩn hoá số âm: \texttt{((x \% MOD) + MOD) \% MOD}.

\begin{lstlisting}[caption={Lũy thừa nhanh và nghịch đảo modulo (C++)}]
const long long MOD = 1000000007LL;

long long modpow(long long a, long long e){
    long long r = 1 % MOD;
    a %= MOD;
    while(e){
        if(e & 1) r = (r * a) % MOD;
        a = (a * a) % MOD;
        e >>= 1;
    }
    return r;
}

long long modinv(long long a){
    a %= MOD; if(a < 0) a += MOD;
    return modpow(a, MOD - 2);
}
\end{lstlisting}

\paragraph{Tiền xử lý giai thừa \& nghịch đảo giai thừa}
Sau $O(N)$ chuẩn bị, tính $\binom{n}{k}$ trong $O(1)$.

\begin{lstlisting}[caption={Precompute factorial / invfactorial; tính C(n,k)}]
const int MOD = 1000000007;
const int MAXN = 2000000; 

int fact[MAXN+1], invfact[MAXN+1];

int modpow_int(int a, long long e){
    long long r = 1, b = (a % MOD + MOD) % MOD;
    while(e){
        if(e & 1) r = (r * b) % MOD;
        b = (b * b) % MOD;
        e >>= 1;
    }
    return (int)r;
}
void init_fact(){
    fact[0] = 1;
    for(int i=1;i<=MAXN;i++) fact[i] = (long long)fact[i-1]*i % MOD;
    invfact[MAXN] = modpow_int(fact[MAXN], MOD-2);
    for(int i=MAXN;i>=1;i--) invfact[i-1] = (long long)invfact[i]*i % MOD;
}
int C(int n, int k){
    if(k < 0 || k > n) return 0;
    return (long long)fact[n]*invfact[k]%MOD*invfact[n-k]%MOD;
}
\end{lstlisting}

\section{Bài tập}

\begin{baitap}{Ball in Berland}{https://codeforces.com/problemset/problem/1475/C}


Ở trường của Vasya đang chuẩn bị cho lễ tốt nghiệp. Một trong những tiết mục là buổi dạ hội, nơi các cặp nam–nữ sẽ khiêu vũ.

Mỗi lớp phải cử \textit{hai} cặp tham dự. Ở lớp của Vasya có $a$ bạn nam và $b$ bạn nữ muốn tham gia, nhưng không phải tất cả đều sẵn sàng nhảy cặp.

Cụ thể, bạn biết $k$ cặp nam–nữ có thể ghép được. Hãy chọn \textbf{hai} cặp trong số đó sao cho \textbf{không người nào xuất hiện trong quá một cặp}.

Ví dụ, nếu $a=3$, $b=4$, $k=4$ và các cặp $ (1,2), (1,3), (2,2), (3,4) $ sẵn sàng nhảy (trong mỗi cặp, số của bạn nam đứng trước, rồi đến số của bạn nữ) thì các cách chọn hợp lệ gồm, chẳng hạn: $(1,3)$ và $(2,2)$; $(3,4)$ và $(1,3)$. Những cách không hợp lệ: $(1,3)$ và $(1,2)$ — nam số $1$ xuất hiện hai lần; $(1,2)$ và $(2,2)$ — nữ số $2$ xuất hiện hai lần.

Hãy đếm số cách chọn hai cặp thỏa điều kiện trên. Hai cách được coi là khác nhau nếu chúng gồm các cặp khác nhau.

\textbf{Input}
\begin{itemize}[noitemsep]
    \item Dòng đầu chứa một số nguyên $t$ ($1 \le t \le 10^4$) — số bộ test. 
    \item Với mỗi bộ test: dòng đầu chứa ba số nguyên $a$, $b$, $k$ ($1 \le a,b,k \le 2\cdot 10^5$) — số bạn nam, số bạn nữ và số cặp có thể ghép.
    \item Dòng thứ hai chứa $k$ số $a_1,a_2,\ldots,a_k$ ($1 \le a_i \le a$), trong đó $a_i$ là số của bạn nam ở cặp thứ $i$.
    \item Dòng thứ ba chứa $k$ số $b_1,b_2,\ldots,b_k$ ($1 \le b_i \le b$), trong đó $b_i$ là số của bạn nữ ở cặp thứ $i$.
    \item Bảo đảm tổng các giá trị $a$, $b$ và $k$ qua tất cả các test không vượt quá $2\cdot 10^5$.
    \item Bảo đảm mỗi cặp $(a_i,b_i)$ xuất hiện nhiều nhất một lần trong một test.
\end{itemize}

\textbf{Output} \\
Với mỗi bộ test, in ra một số nguyên — số cách chọn hai cặp thỏa điều kiện.



\end{baitap}

\textbf{Ví dụ}
\begin{sampleio}
3 & 4 \\
3 4 4 & 0 \\
1 1 2 3 & 2 \\
2 3 2 4 & \\
1 1 1 & \\
1 & \\
1 & \\
2 2 4 & \\
1 1 2 2 & \\
1 2 1 2 & \\
\end{sampleio}

\textbf{Phân tích bài toán}

Gọi \texttt{boy[i]} và \texttt{girl[i]} lần lượt là chỉ số của bạn nam và bạn nữ trong cặp thứ $i$.

Bài toán yêu cầu đếm số cặp $(i, j)$ với $i \neq j$ sao cho \texttt{boy[i]} $\neq$ \texttt{boy[j]} và \texttt{girl[i]} $\neq$ \texttt{girl[j]}.  
Nếu làm trực tiếp bằng cách duyệt tất cả các cặp $(i, j)$ thì độ phức tạp $O(k^2)$, quá lớn khi $k \leq 2 \cdot 10^5$.

Ý tưởng tối ưu như sau:

\begin{itemize}
    \item Khi đang xét cặp thứ $i$, rõ ràng có $i-1$ cặp trước đó có thể kết hợp với nó.
    \item Ta phải loại bỏ những cặp trùng bạn nam hoặc bạn nữ:
    \begin{itemize}
        \item Có \texttt{mb[boy[i]]} cặp trước đó có cùng bạn nam.
        \item Có \texttt{mg[girl[i]]} cặp trước đó có cùng bạn nữ.
    \end{itemize}
    \item Như vậy sau khi loại bỏ, ta còn $M$ cặp thỏa mãn. Với mỗi cặp trong $M$ cặp, ta đều ghép được với cặp thứ $i$. Vậy số cặp hợp lệ có thể ghép với $i$ là: $(i - 1) - \texttt{mb[boy[i]]} - \texttt{mg[girl[i]]}$
\end{itemize}

Độ phức tạp mỗi test là $O(k \log k)$, phù hợp với ràng buộc đề bài.

\begin{lstlisting}[title=\centering \textbf{Cài đặt}]
#include <bits/stdc++.h>
#define int long long
using namespace std;

signed main() {
    int t; cin >> t;
    while (t--) {
        int a, b, k; cin >> a >> b >> k;
        vector<int> boy(k + 1), girl(k + 1);
        for (int i = 1; i <= k; i++) {
            cin >> boy[i];
        }
        for (int i = 1; i <= k; i++) {
            cin >> girl[i];
        }
        map<int,int> mb, mg;
        mb[boy[1]]++, mg[girl[1]]++;
        int ans = 0;
        for (int i = 2; i <= k; i++) {
            int group = i - 1;
            group -= mb[boy[i]];
            group -= mg[girl[i]];
            ans += group;
            mb[boy[i]]++;
            mg[girl[i]]++;
        }
        cout << ans << endl;
    }
}
\end{lstlisting}

\begin{baitap}{Binomial Coefficients}{https://cses.fi/problemset/task/1079}

\textbf{Đề bài:}  

Nhiệm vụ của bạn là tính $n$ hệ số nhị thức theo modulo $10^9+7$.  
Hệ số nhị thức $\binom{a}{b}$ được tính theo công thức:
\[
\binom{a}{b} = \frac{a!}{b!(a-b)!}.
\]
Giả sử $a, b$ là số nguyên và $0 \le b \le a$.

\textbf{Input}
\begin{itemize}[noitemsep]
    \item Dòng đầu chứa một số nguyên $n$: số lượng phép tính cần thực hiện.
    \item Sau đó là $n$ dòng, mỗi dòng gồm hai số nguyên $a$ và $b$.
\end{itemize}

\textbf{Output} \\
In ra kết quả của từng hệ số nhị thức theo modulo $10^9+7$.

\textbf{Ràng buộc}
\begin{itemize}[noitemsep]
    \item $1 \le n \le 10^5$
    \item $0 \le b \le a \le 10^6$
\end{itemize}

\textbf{Ví dụ}

\begin{sampleio}
3 & \\
5 3 & 10 \\
8 1 & 8 \\
9 5 & 126 \\
\end{sampleio}

\end{baitap}

\textbf{Phân tích bài toán}

Bài toán yêu cầu tính $\binom{a}{b} \pmod{10^9+7}$ với nhiều truy vấn.

Với giá trị $a$ có thể lên tới $10^6$, và số truy vấn $n$ có thể tới $10^5$. Nếu mỗi lần tính giai thừa lại từ đầu thì quá chậm với độ phức tạp tệ nhất là $10^5 \cdot (10^6 + 10^6)$.

\textbf{Ý tưởng tối ưu:}
\begin{itemize}
    \item Tiền xử lý mảng giai thừa \texttt{fact[i]} = $i! \pmod{MOD}$ với $i$ từ $0 \to N$, $N = 10^6$.
    \item Cần thêm nghịch đảo giai thừa. Vì $MOD$ là số nguyên tố, áp dụng định lý Fermat:
    \[
    x^{-1} \equiv x^{MOD-2} \pmod{MOD}.
    \]
    \item Trước tiên, tính \texttt{invfact[N]} = $(N!)^{-1} \pmod{MOD}$ bằng một lần lũy thừa nhanh.
    \item Sau đó xây dựng toàn bộ mảng \texttt{invfact} bằng công thức:
    \[
    invfact[i-1] = invfact[i] \cdot i \pmod{MOD}, \quad 1 \le i \le N.
    \]
    \item Khi đó, với mỗi truy vấn:
    \[
    \binom{a}{b} = \texttt{fact}[a] \cdot \texttt{invfact}[b] \cdot \texttt{invfact}[a-b] \pmod{MOD}.
    \]
\end{itemize}

\textbf{Độ phức tạp:}
\begin{itemize}
    \item Tính \texttt{fact}: $O(N)$.
    \item Tính một lần lũy thừa nhanh: $O(\log MOD)$.
    \item Xây dựng \texttt{invfact}: $O(N)$.
    \item Mỗi truy vấn trả lời trong $O(1)$.
\end{itemize}

Vậy tổng độ phức tạp: $O(N + \log MOD + n)$

\begin{lstlisting}[title=\centering \textbf{Cài đặt}]
#include <bits/stdc++.h> 
#define int long long
using namespace std;
const int MOD = 1e9 + 7;
 
int quick_mod(int a, int n) {
	if (n == 0) return 1;
	int x = quick_mod(a, n / 2);
	x = x * x % MOD;
	if (n % 2 == 1) x = x * a % MOD;
	return x;
}
 
signed main() {
	vector<int> fact(1e6 + 1), inv_fact(1e6+1);
	fact[0] = 1;
	for (int i = 1; i <= 1e6; i++) {
		fact[i] = (fact[i - 1] * i) % MOD;
	}
	inv_fact[0] = 1;
	for (int i = 1; i <= 1e6; i++) {
		inv_fact[i] = quick_mod(fact[i], MOD - 2) % MOD;
	}
 
	int n; cin >> n;
	while (n--) {
		int n, k; cin >> n >> k;
		cout << (fact[n] % MOD * inv_fact[k] % MOD * inv_fact[n - k] % MOD) % MOD << endl;
	}
}
\end{lstlisting}



\begin{baitap}{Distributing Apples}{https://cses.fi/problemset/task/1716}

\textbf{Đề bài:}  

Có $n$ đứa trẻ và $m$ quả táo sẽ được phân phát cho chúng. Nhiệm vụ của bạn là đếm số cách phân phát.  
Ví dụ, nếu $n=3$ và $m=2$, có 6 cách:  
\[
[0,0,2], [0,1,1], [0,2,0], [1,0,1], [1,1,0], [2,0,0].
\]

\textbf{Input}
\begin{itemize}[noitemsep]
    \item Dòng duy nhất chứa hai số nguyên $n$ và $m$.
\end{itemize}

\textbf{Output} \\
In ra số cách phân phát modulo $10^9+7$.

\textbf{Ràng buộc}
\begin{itemize}[noitemsep]
    \item $1 \le n,m \le 10^6$
\end{itemize}

\textbf{Ví dụ}

\begin{sampleio}
3 2 & 6 \\
\end{sampleio}

\end{baitap}


\textbf{Phân tích bài toán}

Xét bài toán chia kẹo Euler: Có $N$ viên kẹo, $K$ đứa trẻ, hãy đếm số cách chia sao cho \textbf{mỗi đứa phải có ít nhất 1} viên kẹo.

\textbf{Ví dụ chia kẹo Euler:} $N=4$, $K=3$. Những cách chia thỏa là: $[1,1,2], [1,2,1], [2,1,1]$.

Để trực quan hơn, tưởng tượng 4 viên kẹo được minh họa như sau (ký tự ``o'' đại diện 1 viên kẹo):
\[
o\ \ o\ \ o\ \ o
\]
Việc chia kẹo cho 3 đứa trẻ giống như đặt $K-1=2$ vách ngăn vào các \emph{khe} giữa các viên kẹo; mỗi cách đặt cho ta một cách chia khác nhau. Ký hiệu ``|'' là vách ngăn:
\[
o\ \mid\ o\ \mid\ o\ o
\]
\[
o\ o\ \mid\ o\ \mid\ o
\]
\[
o\ \mid\ o\ o\ \mid\ o
\]
Như vậy, bài toán chia kẹo Euler đưa về: đếm số cách đặt $K-1$ vách ngăn vào $N-1$ khe kẹo. Suy ra đáp án là
\[
\binom{N-1}{K-1}.
\]

\medskip
Quay lại \textbf{bài toán hiện tại} (mỗi đứa có thể nhận $0$): với ví dụ $N=4$, $K=3$, ta có thể hình dung như sau.

Ta \emph{tạm} chia $(N+K)$ quả táo cho $K$ đứa trẻ sao cho \textbf{mỗi đứa có ít nhất 1} quả. Sau khi chia xong, ta \emph{lấy lại} mỗi đứa 1 quả. Rõ ràng phép “cộng mỗi đứa 1 rồi trừ đi 1” này là tương ứng 1–1 với các cách chia ban đầu có thể nhận $0$.

Do đó số cách cần tìm là số cách chia dương của tổng $N+K$, tức:
\[
\binom{N+K-1}{K-1}
\]
(tương đương \(\binom{N+K-1}{N}\)).


\begin{lstlisting}[title=\centering \textbf{Cài đặt}]
\end{lstlisting}