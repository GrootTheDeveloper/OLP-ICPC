\section{Hash \& String}

\subsection{Đếm số lần xuất hiện của $T$ trong $S$ (Z-algorithm, $O(|S|{+}|T|)$)}

\textbf{Ý tưởng.} Tạo xâu $X = T + '\#' + S$ (ký tự ngăn cách không xuất hiện trong $S,T$), tính mảng $Z$ của $X$.  
Mỗi vị trí $i$ trong phần $S$ có một khớp $T$ nếu $Z[i] \ge |T|$. Tổng số vị trí như vậy là đáp án.

\codefile[]{code/count_substring_occurrences_z.cpp}

\subsection{Chu kỳ ngắn nhất của xâu (minimal period)}

\textbf{Bài toán.} Tìm xâu $T$ ngắn nhất sao cho lặp $T$ đủ $n$ ký tự thì được $S$.

\textbf{Ý tưởng (KMP prefix function).}
Tính $\pi[i] =$ độ dài tiền tố dài nhất cũng là hậu tố của $S[0..i]$.  
Gọi $p = n - \pi[n-1]$. Khi đó:
\[
\text{Nếu } n \bmod p = 0 \Rightarrow T = S[0..p-1],\quad
\text{ngược lại } T = S.
\]

\codefile[]{code/minimal_period_string.cpp}

\subsection{So sánh \textbf{tập} của các tiền tố hai mảng $A$ và $B$}

\textbf{Đề bài.} Cho hai mảng $A,B$ độ dài $n$. Với mỗi truy vấn $(i,j)$, xét hai \emph{tập}:
\[
S_A(i)=\{A_1,\dots,A_i\},\qquad S_B(j)=\{B_1,\dots,B_j\}.
\]
Hỏi $S_A(i)$ và $S_B(j)$ có bằng nhau không?

\textbf{Ý tưởng.} Tiền xử lý hai dãy:
\[
\text{reachA}[i] = \min\{\,j \mid S_A(i)\subseteq S_B(j)\,\},\quad
\text{reachB}[j] = \min\{\,i \mid S_B(j)\subseteq S_A(i)\,\}.
\]
Tính bằng hai con trỏ với \emph{tập} đã thấy (chỉ quan tâm sự xuất hiện, không đếm số lần):
\begin{itemize}
\item Duyệt $i=1..n$, mỗi khi gặp phần tử mới trong $A$ mà chưa có trong $B[1..j]$ thì tăng biến \texttt{need}. Tăng $j$ và “thêm” các phần tử trong $B$ cho tới khi \texttt{need}=0. Khi đó \texttt{reachA[i]=j} (nếu không đạt, đặt $\infty$).
\item Tương tự, tráo vai $A\leftrightarrow B$ để có \texttt{reachB}.
\end{itemize}
Với truy vấn $(i,j)$, $S_A(i)=S_B(j)$ \textbf{iff} \(\text{reachA}[i]\le j\) \emph{và} \(\text{reachB}[j]\le i\) (bao hàm 2 chiều).

Độ phức tạp tiền xử lý $O(n)$ trung bình (unordered\_set), mỗi truy vấn $O(1)$.

\codefile[]{code/prefix_set_equality_queries.cpp}
\subsection{Xâu xoay từ điển nhỏ nhất (Lexicographically Minimal Rotation)}

\textbf{Đề bài.}  
Một \textbf{xâu xoay (cyclic shift)} được tạo bằng cách chuyển ký tự cuối của xâu lên đầu (hoặc ngược lại) nhiều lần.  
Ví dụ với \texttt{S = "marisa"}:  
\[
\text{marisa},\ \text{amaris},\ \text{samari},\ \text{isamar},\ \text{risama},\ \text{arisam}
\]  
Yêu cầu: Tìm \textbf{xâu xoay nhỏ nhất theo thứ tự từ điển} của xâu \(S\).

\textbf{Ràng buộc.}
\[
1 \le |S| \le 10^6
\]

\textbf{Ý tưởng.}  
- Nếu duyệt tất cả các xoay và so sánh → \(O(n^2)\), quá chậm.  
- Dùng \textbf{Thuật toán Booth} để tìm vị trí bắt đầu của xoay nhỏ nhất, độ phức tạp \(O(n)\).  
  
\textbf{Thuật toán Booth (tóm tắt):}
\begin{itemize}
    \item Gộp xâu với chính nó: \(T = S + S\)
    \item Dùng hai con trỏ \(i, j\) để tìm vị trí bắt đầu tốt nhất.
    \item Nếu \(T[i + k] = T[j + k]\) thì tăng \(k\).  
    \item Nếu \(T[i + k] > T[j + k]\) thì bỏ toàn bộ từ \(i\) đến \(i+k\), cập nhật \(i = i + k + 1\).
    \item Nếu \(T[i + k] < T[j + k]\) → tương tự cho \(j\).
    \item Kết quả là \(\min(i, j)\).
\end{itemize}

\textbf{Độ phức tạp:} \(O(n)\) thời gian, \(O(1)\) bộ nhớ.

\codefile[]{code/minimal_rotation.cpp}

\subsection{Xâu dài nhất xuất hiện $\ge k$ lần}

\textbf{Ý tưởng (Suffix Array + LCP).}
Gọi $SA$ là mảng suffix, $LCP[i]=\text{lcp}(\text{suffix }SA[i-1], SA[i])$ (Kasai).  
Một xâu xuất hiện $\ge k$ lần tương ứng với \textbf{một cửa sổ} $k$ suffix liên tiếp trong $SA$; độ dài lớn nhất trong cửa sổ đó là
\[
\min(LCP[i-k+2],\,LCP[i-k+3],\,\dots,\,LCP[i])\quad (i \text{ là rìa phải cửa sổ}).
\]
Quét rìa phải $i=1..n-1$, duy trì \textbf{deque} giá trị nhỏ nhất (RMQ trượt) trên $LCP$ với kích thước hiệu dụng $k{-}1$.  
Đáp án là max của các minimum này. Trường hợp $k=1$ trả ngay $|S|$.

\textbf{Độ phức tạp.} Xây $SA$ bằng doubling $O(n\log n)$, Kasai $O(n)$, cửa sổ trượt $O(n)$.

\codefile[]{code/longest_substring_at_least_k_times_sa.cpp}

\subsection{Xâu con dài nhất ghép được từ bộ từ điển}

\textbf{Bài toán.} Cho xâu $S$ (|S| $\le 2000$) và $n$ mẫu $T_1,\dots,T_n$ (tổng độ dài $\le 10^5$). Tìm độ dài \emph{xâu con liên tiếp} dài nhất của $S$ có thể biểu diễn như phép \textbf{nối liên tiếp} các mẫu (mỗi mẫu dùng nhiều lần được).

\textbf{Ý tưởng.}
\begin{enumerate}
\item Dùng \textbf{Aho–Corasick} để tìm tất cả kết quả khớp mẫu trong $S$. Với mỗi vị trí bắt đầu $i$, lưu danh sách các điểm kết thúc $j$ sao cho $S[i..j]$ là một mẫu. Ta có đồ thị DAG trên các vị trí $0..|S|$: cạnh $i \to j{+}1$ nếu tồn tại mẫu khớp $S[i..j]$.
\item Với mỗi điểm bắt đầu $l$ (0-based), duyệt tuyến tính các vị trí từ $l$ tới $|S|$:
\[
\text{reachable}[l]=\text{true},\quad 
\text{nếu reachable}[i] \Rightarrow \forall (i\to t)\ \ \text{reachable}[t]=\text{true}.
\]
Giá trị xa nhất $r$ với \(\text{reachable}[r]=\text{true}\) cho ta một xâu con hợp lệ $S[l..r-1]$ có độ dài $r-l$. Lấy max trên mọi $l$.
\end{enumerate}
\textbf{Độ phức tạp.} Xây Aho $O(\sum|T_i| + \Sigma)$, quét $S$ sinh cạnh $O(|S|+\#matches)$, và với $|S|\le 2000$ ta làm $|S|$ lần duyệt tuyến tính $\Rightarrow$ tổng chạy tốt.

\codefile[]{code/longest_concat_substring_aho.cpp}


\section{Hình học}


\begin{itemize}
    \item \textbf{Vector:}  
    $\vec{AB} = (x_B - x_A,\ y_B - y_A)$

    \item \textbf{Tích vô hướng (Dot):}  
    $\vec{a} \cdot \vec{b} = a_x b_x + a_y b_y$  
    $|\vec{a}| = \sqrt{\vec{a} \cdot \vec{a}}$  
    $\cos \theta = \dfrac{\vec{a} \cdot \vec{b}}{|\vec{a}||\vec{b}|}$

    \item \textbf{Tích có hướng (Cross):}  
    $\vec{a} \times \vec{b} = a_x b_y - a_y b_x$  
    Ý nghĩa:
    \begin{itemize}
        \item $> 0$: $\vec{a} \to \vec{b}$ quay ngược chiều kim đồng hồ (CCW)
        \item $< 0$: quay thuận chiều kim đồng hồ (CW)
        \item $= 0$: thẳng hàng
    \end{itemize}

    \item \textbf{Diện tích tam giác $ABC$:}  
    $S_{\triangle ABC} = \dfrac{|\vec{AB} \times \vec{AC}|}{2}$

    \item \textbf{Diện tích đa giác (Shoelace):}  
    Với các điểm $P_1,\dots,P_n$:  
    $$
    S = \dfrac{1}{2}\left| \sum_{i=1}^{n} (x_i y_{i+1} - y_i x_{i+1}) \right|
    \quad \text{với } P_{n+1} = P_1
    $$

    \item \textbf{Khoảng cách từ $P$ đến đường thẳng $(AB)$:}  
    $d(P,AB) = \dfrac{|\vec{AP} \times \vec{AB}|}{|\vec{AB}|}$

    \item \textbf{Khoảng cách từ $P$ đến đoạn $AB$:}  
    \begin{itemize}
        \item Nếu hình chiếu $H$ của $P$ nằm trên $AB$:  
        $d = \dfrac{|\vec{AP} \times \vec{AB}|}{|\vec{AB}|}$
        \item Ngược lại: $d = \min(|\vec{AP}|,\ |\vec{BP}|)$
    \end{itemize}

    \item \textbf{Điểm thuộc đoạn thẳng:}  
    $P$ thuộc $AB \iff \vec{AP} \times \vec{AB} = 0 \ \text{và}\ \vec{AP} \cdot \vec{BP} \le 0$

    \item \textbf{Hai đoạn $AB$ và $CD$ cắt nhau nếu:}  
    $ccw(A,B,C) \cdot ccw(A,B,D) \le 0$  
    và  
    $ccw(C,D,A) \cdot ccw(C,D,B) \le 0$

    \item \textbf{Góc giữa hai vector:}  
    $\cos \theta = \dfrac{\vec{a} \cdot \vec{b}}{|\vec{a}||\vec{b}|}$,\quad
    $\sin \theta = \dfrac{|\vec{a} \times \vec{b}|}{|\vec{a}||\vec{b}|}$

    \item \textbf{Đường tròn:}  
    Chu vi $= 2\pi r$,\quad Diện tích $= \pi r^2$

    \item \textbf{Diện tích tam giác theo 3 cạnh (Heron):}  
    $p = \dfrac{a+b+c}{2}$,\quad
    $S = \sqrt{p(p-a)(p-b)(p-c)}$

    \item \textbf{Đường tròn nội tiếp:}  
    Tâm là giao của 3 đường phân giác,\quad
    $r = \dfrac{2S}{a+b+c}$

    \item \textbf{Đường tròn ngoại tiếp:}  
    Tâm là giao của 3 trung trực,\quad
    $R = \dfrac{abc}{4S}$
\end{itemize}
